/* From repo Whitesad/ACM */
/* Written by Whitesad */
/* Written by Whitesad */
/* Written by Whitesad */
/* Written by Whitesad */
//utf8
/*
H22【应用】编码（选作）
成绩 	5 	开启时间 	2018年12月2日 星期日 14:00
折扣 	0.8 	折扣时间 	2018年12月30日 星期日 23:55
允许迟交 	否 	关闭时间 	2018年12月30日 星期日 23:55
描述
为了最大程度地节约存储空间，经常需要把信息进行编码。一种很有效的编码方法是用数字来表示一串字符。
假设这些字符串都是由不重复的英文小写字母组成的，且每个字符串中的英文字母都是从小到大排列的。
这个编码系统按照如下的方式工作：
    字符串是按照长度从小到大的顺序排列的
    长度相同的字符串，是按照字典需排列的
则根据这个编码系统，所有的字符串从 a 开始可以编码如下：
a - 1 b - 2 ... z - 26 ab - 27 ... az - 51 bc - 52 ... vwxyz - 83681 ...
那么，请编程计算出一个字符串在这个编码系统下编码后的值是多少。
输入
输入的第一行为 N（0<=N<=1000000），表示有 N 组数据。后面的 N 行每行包含一个不超过 10 个字母的字符串。
输出
输出字符串所对应的编码，如果该字符串不能被编码，则输出 0。
*/
/*
这其实是一道组合数学题，主要思想其实就是当前位置的所有可能为C(n,m)，n为长度，m为可用字符数量
然后你没有看错我TM用排列做的
打表0.7s飘过，可还行
*/
/* Written by Whitesad */
#include <stdio.h>
#include <string.h>
#include <math.h>
/* Written by Whitesad */
typedef long long ll;
long long factor[11][27] = {[1][1] = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, [2][2] = 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240, 272, 306, 342, 380, 420, 462, 506, 552, 600, 650, [3][3] = 6, 24, 60, 120, 210, 336, 504, 720, 990, 1320, 1716, 2184, 2730, 3360, 4080, 4896, 5814, 6840, 7980, 9240, 10626, 12144, 13800, 15600, [4][4] = 24, 120, 360, 840, 1680, 3024, 5040, 7920, 11880, 17160, 24024, 32760, 43680, 57120, 73440, 93024, 116280, 143640, 175560, 212520, 255024, 303600, 358800, [5][5] = 120, 720, 2520, 6720, 15120, 30240, 55440, 95040, 154440, 240240, 360360, 524160, 742560, 1028160, 1395360, 1860480, 2441880, 3160080, 4037880, 5100480, 6375600, 7893600, [6][6] = 720, 5040, 20160, 60480, 151200, 332640, 665280, 1235520, 2162160, 3603600, 5765760, 8910720, 13366080, 19535040, 27907200, 39070080, 53721360, 72681840, 96909120, 127512000, 165765600, [7][7] = 5040, 40320, 181440, 604800, 1663200, 3991680, 8648640, 17297280, 32432400, 57657600, 98017920, 160392960, 253955520, 390700800, 586051200, 859541760, 1235591280, 1744364160, 2422728000, 3315312000, [8][8] = 40320, 362880, 1814400, 6652800, 19958400, 51891840, 121080960, 259459200, 518918400, 980179200, 1764322560, 3047466240, 5079110400, 8204716800, 12893126400, 19769460480, 29654190720, 43609104000, 62990928000, [9][9] = 362880, 3628800, 19958400, 79833600, 259459200, 726485760, 1816214400, 4151347200, 8821612800, 17643225600, 33522128640, 60949324800, 106661318400, 180503769600, 296541907200, 474467051520, 741354768000, 1133836704000, [10][10] = 3628800, 39916800, 239500800, 1037836800, 3632428800, 10897286400, 29059430400, 70572902400, 158789030400, 335221286400, 670442572800, 1279935820800, 2346549004800, 4151586700800, 7117005772800, 11861676288000, 19275223968000};
long long A(int i, int j) //排列
{
    if (i == 0)
        return 1;
    return factor[i][j];
}
/* Written by Whitesad */
int legal(const char *str)
{
    int vis[30];
    int i;
    memset(vis, 0, sizeof(vis));
    int result = 1;
    for (i = 0; str[i]; i++)
    {
        vis[str[i] - 'a']++;
        if (vis[str[i] - 'a'] > 1)
            result = 0; //查重
        if (i && str[i] < str[i - 1])
            result = 0; //查严格递增
    }
    return result;
}
/* Written by Whitesad */
int main(int argc, char const *argv[])
{
    int num;
    char str[15];
    scanf("%d", &num);
    getchar();
    ll ans;
    int i;
    while (num--)
    {
        gets(str);
        if (!legal(str))
        {
            printf("0\n");
            continue;
        }
        int len = strlen(str);
        ans = 0;
        for (i = 1; i < len; i++)
            ans += A(i, 26) / A(i, i);
        int n, m;
        char front = 'a' - 1;
        char count;
        for (i = 0; i < len; i++)
        {
            count = front + 1;
            n = len - i - 1;
            for (; count < str[i]; count++) //MAGIC,梦中想出来的，我干了什么？
            {
                m = 'z' - count;
                ans += A(n, m) / A(n, n);
            }
            front = str[i];
        }
        printf("%lld\n", ans + 1);
    }
    return 0;
}
/* Written by Whitesad */